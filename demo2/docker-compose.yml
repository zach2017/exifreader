version: "3.8"

# ─────────────────────────────────────────────────────────────
#  PDF & Image OCR Extraction Stack
#
#  LocalStack 3.x+ runs Lambdas in SEPARATE Docker containers
#  (no more LAMBDA_EXECUTOR=local). We:
#    1. Build a custom Lambda runtime image with Tesseract/Poppler
#    2. Tell LocalStack to use it via LAMBDA_RUNTIME_IMAGE_MAPPING
#    3. Mount Docker socket so LocalStack can spawn Lambda containers
#    4. Use a deployer that waits for function Active state
#
#  Startup order:
#    lambda-image (build only) → localstack → deployer → backend → frontend
# ─────────────────────────────────────────────────────────────

services:

  # ── 1. Build custom Lambda runtime image ──────────────────
  # Extends public.ecr.aws/lambda/python:3.11 with Tesseract + Poppler.
  # The 'image:' tag makes it available as 'lambda-ocr-python311' on
  # the Docker daemon. LocalStack picks it up via LAMBDA_RUNTIME_IMAGE_MAPPING.
  lambda-image:
    build: ./lambda-image
    image: lambda-ocr-python311
    container_name: ocr-lambda-image-builder
    entrypoint: ["echo", "Lambda OCR image built successfully"]
    networks:
      - ocr-net

  # ── 2. LocalStack ─────────────────────────────────────────
  localstack:
    image: localstack/localstack:latest
    container_name: ocr-localstack
    ports:
      - "4566:4566"
    environment:
      - SERVICES=lambda,iam,logs
      - DEBUG=1
      # Map python3.11 runtime to our custom image with Tesseract
      - LAMBDA_RUNTIME_IMAGE_MAPPING={"python3.11":"lambda-ocr-python311"}
      # Lambda containers must be on the same Docker network
      - LAMBDA_DOCKER_NETWORK=ocr-net
      # Faster startup
      - EAGER_SERVICE_LOADING=1
      # Pre-pull/build images to speed up first invocation
      - LAMBDA_PREBUILD_IMAGES=1
    volumes:
      # REQUIRED: LocalStack needs Docker socket to spawn Lambda containers
      - /var/run/docker.sock:/var/run/docker.sock
      - localstack-data:/var/lib/localstack
    healthcheck:
      test: ["CMD", "curl", "-sf", "http://localhost:4566/_localstack/health"]
      interval: 5s
      timeout: 5s
      retries: 20
      start_period: 15s
    depends_on:
      lambda-image:
        condition: service_completed_successfully
    networks:
      - ocr-net

  # ── 3. Deployer: packages zip, creates function, waits for Active ──
  deployer:
    build: ./deployer
    container_name: ocr-deployer
    volumes:
      - ./lambda-image/handler.py:/src/handler.py:ro
    environment:
      - AWS_ACCESS_KEY_ID=test
      - AWS_SECRET_ACCESS_KEY=test
      - AWS_DEFAULT_REGION=us-east-1
    depends_on:
      localstack:
        condition: service_healthy
    networks:
      - ocr-net

  # ── 4. Flask Backend ──────────────────────────────────────
  backend:
    build: ./backend
    container_name: ocr-backend
    ports:
      - "5000:5000"
    environment:
      - AWS_ACCESS_KEY_ID=test
      - AWS_SECRET_ACCESS_KEY=test
      - AWS_DEFAULT_REGION=us-east-1
      - LOCALSTACK_ENDPOINT=http://localstack:4566
      - LAMBDA_FUNCTION_NAME=ocr-extract
    depends_on:
      deployer:
        condition: service_completed_successfully
    networks:
      - ocr-net

  # ── 5. Nginx Frontend ────────────────────────────────────
  frontend:
    build: ./frontend
    container_name: ocr-frontend
    ports:
      - "8080:80"
    depends_on:
      - backend
    networks:
      - ocr-net

volumes:
  localstack-data:

networks:
  ocr-net:
    name: ocr-net
    driver: bridge
